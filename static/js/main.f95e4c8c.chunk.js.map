{"version":3,"sources":["components/PlayButton.js","components/NN.js","components/ScatterPlot.js","App.js","reportWebVitals.js","index.js"],"names":["PlayButton","playing","Fab","style","background","color","Stop","PlayArrow","NN","props","state","initNeuralNetwork","bind","node","this","shape","weights","slowed","svg","xScale","d3","domain","range","yScale","start","x","y","stop","link","d","rw","rh","layerProportion","ns","flatns","push","layer","length","dense","neuron","aaron","links","prevNeuron","source","target","flattenedWeights","flatten","selectAll","data","enter","append","attr","Math","pow","array","flattendArray","i","e","weightModel","revereseFlatten","console","log","weightsIndex","connections","connectionArray","w","reverse","select","children","id","Component","ScatterPlot","formattedPoints","a","width","height","padding","X","container","xAxis","scale","yAxis","call","yhat","dataSet","remove","plotPoints","App","duringEpoch","biasData","weightsData","model","seq","neurons","loss","dlossdyhat","epoch","lr","curve","optimizer","controls","speed","main","run","neuralNetwork","initDenseNeuron","initializeModel","linkModel","forwardModel","backwardModel","updateModel","setInputs","generateData","genTensorData","linearData","mutate","mutateModelNeurons","passBack","mutateAllBackward","train","printParameters","reset","asyncPause","resetParameters","changeModelLr","changeModelOptimizer","optimizerChange","modelCompile","lrChange","tf","optimizer_","learningRate","number","max","array1","array2","map","item","reduce","b","floor","random","timer","ms","Promise","res","setTimeout","getRandomInt","increment","eqn","newShape","numLayers","numNeurons","numInputs","DenseNeuronTemplate","forward","inputs","bias","product","sum","activation","output","backward","dvalue","dReLU","dBias","dMult","dWeights","dInputs","dNeuron","index","io","mult","ReLU","relu","mseLoss","currentLayer","prevLayer","outputLayerIndex","dyhat","mseDerivative","dNeurons","dNeuronsSum","param","dparam","updatedWeights","weight","gradientDescent","updatedBias","equation","undefined","input","toFixed","error","end","key","subkey","value","setState","tensor","Array","from","dataSync","add","inputShape","units","useBias","addModel","compile","play","fit","epochs","h","predict","history","tensorToArray","scaled","XTensor","yTensor","yhatTensor","weightSet","biasSet","getWeights","adam","sgd","splice","lrs","dataSets","label","PlayButtonClick","onClick","AppBar","position","Toolbar","Typography","variant","Box","display","justifyContent","marginTop","Card","CardContent","CardActions","IconButton","disabled","Replay","SlowMotionVideo","Chip","num","marginLeft","biases","minWidth","marginRight","Button","marginBottom","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f95e4c8c.chunk.js","sourcesContent":["/* \n\tDonny Bertucci: @xnought\n\tDate Created: 02/15/2021\n\tSummary: \n\t\tFunctional Component for PlayButton\n\t@Props: playing: false or true\n*/\nimport { Fab } from \"@material-ui/core\";\nimport { PlayArrow, Stop } from \"@material-ui/icons\";\n\nconst PlayButton = ({ playing }) => (\n\t<Fab\n\t\tstyle={{\n\t\t\tbackground: playing ? \"#f44336\" : \"#4caf50\",\n\t\t\tcolor: \"#FFFFFF\",\n\t\t}}\n\t>\n\t\t{playing ? <Stop /> : <PlayArrow />}\n\t</Fab>\n);\n\nexport default PlayButton;\n","import React, { Component } from \"react\";\nimport * as d3 from \"d3\";\nclass NN extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {};\n\t\tthis.initNeuralNetwork = this.initNeuralNetwork.bind(this);\n\t}\n\tinitNeuralNetwork(node) {\n\t\tconst { playing, shape, weights, slowed } = this.props;\n\t\tconst rw = 32;\n\t\tconst rh = 32;\n\t\tconst svg = node;\n\t\tlet xScale = d3.scaleLinear().domain([0, 100]).range([50, 750]);\n\n\t\tlet yScale = d3.scaleLinear().domain([0, 100]).range([500, 0]);\n\n\t\tlet start = { x: 50 - rw / 2, y: 250 - rh / 2 };\n\t\tlet stop = { x: 750 - rw / 2, y: 250 - rh / 2 };\n\n\t\tconst link = d3\n\t\t\t.linkHorizontal()\n\t\t\t.x((d) => d.x + rw / 2)\n\t\t\t.y((d) => d.y + rh / 2);\n\n\t\t/* First we figure our how to create the neurons */\n\t\t/* GIVEN A SHAPE OF [1,2,2,1] */\n\t\tconst layerProportion = [0, 25, 50, 75, 0];\n\t\tlet ns = [];\n\t\tlet flatns = [];\n\t\tns.push([start]);\n\t\tflatns.push(start);\n\t\tfor (let layer = 1; layer < shape.length - 1; layer++) {\n\t\t\tlet dense = [];\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t/* First generate neuron */\n\t\t\t\tlet aaron = {\n\t\t\t\t\tx: xScale(layerProportion[layer]) - rw / 2,\n\t\t\t\t\ty: yScale(92 - neuron * 12) - rh / 2,\n\t\t\t\t};\n\t\t\t\tdense.push(aaron);\n\t\t\t\tflatns.push(aaron);\n\t\t\t}\n\t\t\tns.push(dense);\n\t\t}\n\t\tflatns.push(stop);\n\t\tns.push([stop]);\n\n\t\t/* We start to iterate over ns */\n\t\tlet links = [];\n\t\tfor (let layer = shape.length - 1; layer > 0; layer--) {\n\t\t\tfor (\n\t\t\t\tlet prevNeuron = 0;\n\t\t\t\tprevNeuron < shape[layer - 1];\n\t\t\t\tprevNeuron++\n\t\t\t) {\n\t\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t\tlinks.push(\n\t\t\t\t\t\tlink({\n\t\t\t\t\t\t\tsource: ns[layer - 1][prevNeuron],\n\t\t\t\t\t\t\ttarget: ns[layer][neuron],\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet flattenedWeights = this.flatten(weights);\n\n\t\tsvg.selectAll(\"path\")\n\t\t\t.data(links)\n\t\t\t.enter()\n\t\t\t.append(\"path\")\n\t\t\t.attr(\"fill\", \"none\")\n\t\t\t.attr(\"class\", \"edgeForward\")\n\t\t\t.attr(\"stroke-width\", \"0.5\")\n\t\t\t.attr(\"d\", (d) => d);\n\t\tsvg.selectAll(\"path\")\n\t\t\t.data(flattenedWeights)\n\t\t\t.attr(\"stroke-width\", (d) => Math.pow(d, 2) + 0.2);\n\n\t\tsvg.selectAll(\"rect\")\n\t\t\t.data(flatns)\n\t\t\t.enter()\n\t\t\t.append(\"rect\")\n\t\t\t.attr(\"x\", (d) => d.x)\n\t\t\t.attr(\"y\", (d) => d.y)\n\t\t\t.attr(\"width\", rw)\n\t\t\t.attr(\"height\", rh)\n\t\t\t.attr(\"class\", \"node\");\n\n\t\tif (!playing) {\n\t\t\tsvg.selectAll(\"path\").attr(\"class\", \"edgePaused\");\n\t\t} else if (playing) {\n\t\t\tsvg.selectAll(\"path\").attr(\n\t\t\t\t\"class\",\n\t\t\t\tslowed ? \"edgeSlowed\" : \"edgeForward\"\n\t\t\t);\n\t\t}\n\t}\n\tcomponentDidMount() {\n\t\tconst height = 500;\n\t\tconst width = 800;\n\t\tconst svg = d3\n\t\t\t.select(\"#nn\")\n\t\t\t.append(\"svg\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height)\n\t\t\t.attr(\"overflow\", \"visible\");\n\t\t//svg.append(\"circle\").attr(\"r\", 1000);\n\n\t\tthis.initNeuralNetwork(svg);\n\t}\n\tflatten(array) {\n\t\tlet flattendArray = [];\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tfor (let e = 0; e < array[i].length; e++) {\n\t\t\t\tflattendArray.push(array[i][e]);\n\t\t\t}\n\t\t}\n\t\treturn flattendArray;\n\t}\n\trevereseFlatten(array) {\n\t\tlet flattendArray = [];\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tfor (let e = 0; e < array[i].length; e++) {\n\t\t\t\tflattendArray.push(array[i][e]);\n\t\t\t}\n\t\t}\n\t\treturn flattendArray;\n\t}\n\tperNeuron(weights, shape) {\n\t\tlet weightModel = [];\n\t\tif (weights.length > 0) {\n\t\t\tlet flattenedWeights = this.revereseFlatten(weights);\n\t\t\tconsole.log(flattenedWeights);\n\t\t\tconsole.log(weights);\n\t\t\tlet weightsIndex = 0;\n\t\t\t/* Iterate but not the input node */\n\t\t\t/*  this is an ass algo fix this you idiot  */\n\t\t\tfor (let layer = shape.length - 1; layer > 0; layer--) {\n\t\t\t\t/* Now we want to assign the weight based on number of inputs */\n\t\t\t\tlet dense = [];\n\t\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t\tlet connections = shape[layer - 1];\n\t\t\t\t\tlet connectionArray = [];\n\t\t\t\t\tfor (let w = 0; w < connections; w++) {\n\t\t\t\t\t\tconnectionArray.push(flattenedWeights[weightsIndex]);\n\t\t\t\t\t\tweightsIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tdense.push(connectionArray);\n\t\t\t\t}\n\t\t\t\tweightModel.push(dense);\n\t\t\t}\n\t\t}\n\t\treturn weightModel.reverse();\n\t}\n\tcomponentDidUpdate() {\n\t\tconst svg = d3.select(\"#nn\").select(\"svg\");\n\t\tthis.initNeuralNetwork(svg);\n\n\t\t/* If there is a change to shape do these things */\n\t\t/* First need to create a function to places all of the neurons */\n\t\t/* then need to create a function to that links all of the neurons with stroke */\n\n\t\t/* If there is no change to shape then we just need to change the link stroke */\n\t}\n\trender() {\n\t\tconst { children } = this.props;\n\t\treturn <div id=\"nn\">{children}</div>;\n\t}\n}\n\nexport default NN;\n","import React, { Component } from \"react\";\nimport style from \"./d3.css\";\nimport * as d3 from \"d3\";\n\nclass ScatterPlot extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {};\n\t}\n\n\tplotPoints(node, formattedPoints) {\n\t\t/* Now need to plot said data */\n\t\tnode.selectAll(\"circle\")\n\t\t\t.data(formattedPoints)\n\t\t\t.enter()\n\t\t\t.append(\"circle\")\n\t\t\t.attr(\"cx\", (d) => d.x)\n\t\t\t.attr(\"cy\", (d) => d.y)\n\t\t\t.attr(\"r\", 2)\n\t\t\t.style(\"fill\", \"#F50257\");\n\t}\n\t/* This is where we initialize the Scatter Plot */\n\tasync componentDidMount() {\n\t\tconst { width, height, padding, start, stop, X, y } = this.props;\n\t\tconst container = d3.select(\"#nice\");\n\n\t\tconst svg = container\n\t\t\t.append(\"svg\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height)\n\t\t\t.style(\"overflow\", \"visible\");\n\t\tsvg.append(\"rect\")\n\t\t\t.attr(\"width\", width)\n\t\t\t.attr(\"height\", height)\n\t\t\t.attr(\"class\", \"cord\");\n\t\tlet xScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([0, width - 2 * padding]);\n\n\t\tlet yScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([height - 2 * padding, 0]);\n\n\t\tlet xAxis = d3.axisBottom().scale(xScale);\n\t\tlet yAxis = d3.axisRight().scale(yScale);\n\t\tsvg.append(\"g\")\n\t\t\t.attr(\"class\", \"axis\")\n\t\t\t.attr(\"transform\", `translate(0,${height - 2 * padding})`)\n\t\t\t.call(xAxis);\n\n\t\tsvg.append(\"g\")\n\t\t\t.attr(\"class\", \"axis\")\n\t\t\t.attr(\"transform\", \"translate(\" + (width - 2 * padding) + \",0)\")\n\t\t\t.call(yAxis);\n\n\t\tsvg.append(\"line\")\n\t\t\t.attr(\"x1\", 0)\n\t\t\t.attr(\"y1\", (height + 1) / 2)\n\t\t\t.attr(\"x2\", width)\n\t\t\t.attr(\"y2\", (height + 1) / 2)\n\t\t\t.attr(\"class\", \"split\");\n\t\tsvg.append(\"line\")\n\t\t\t.attr(\"x1\", (width + 1) / 2)\n\t\t\t.attr(\"y1\", 0)\n\t\t\t.attr(\"x2\", (width + 1) / 2)\n\t\t\t.attr(\"y2\", height)\n\t\t\t.attr(\"class\", \"split\");\n\n\t\tsvg.append(\"path\")\n\t\t\t.attr(\"id\", \"epic\")\n\t\t\t.attr(\"stroke\", \"none\")\n\t\t\t.attr(\"fill\", \"none\");\n\t}\n\tcomponentDidUpdate() {\n\t\tconst { width, height, padding, start, stop, X, y, yhat } = this.props;\n\t\tlet xScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([0, width - 2 * padding]);\n\n\t\tlet yScale = d3\n\t\t\t.scaleLinear()\n\t\t\t.domain([start, stop])\n\t\t\t.range([height - 2 * padding, 0]);\n\t\tconst svg = d3.select(\"#nice\").select(\"svg\");\n\t\tlet dataSet = [];\n\t\tfor (let i = 0; i < X.length; i++) {\n\t\t\tdataSet.push({\n\t\t\t\tx: xScale(X[i]),\n\t\t\t\ty: yScale(y[i]),\n\t\t\t});\n\t\t}\n\t\tlet a = [];\n\t\tfor (let i = 0; i < X.length; i++) {\n\t\t\ta.push([xScale(X[i]), yScale(yhat[i])]);\n\t\t}\n\t\tsvg.selectAll(\"circle\").remove();\n\t\tthis.plotPoints(svg, dataSet);\n\n\t\tsvg.select(\"#epic\")\n\t\t\t.attr(\"d\", d3.line()(a))\n\t\t\t.attr(\"stroke\", \"black\")\n\t\t\t.attr(\"fill\", \"none\");\n\t}\n\t//componentDidUpdate() {\n\t//const { width, height, padding, start, stop, X, y } = this.props;\n\t//console.log(X);\n\t//console.log(y);\n\t//let xScale = d3\n\t//.scaleLinear()\n\t//.domain([start, stop])\n\t//.range([0, width - 2 * padding]);\n\n\t//let yScale = d3\n\t//.scaleLinear()\n\t//.domain([start, stop])\n\t//.range([height - 2 * padding, 0]);\n\t//const svg = d3.select(\"#nice\").select(\"svg\");\n\t//let dataSet = [];\n\t//for (let i = 0; i < X.length; i++) {\n\t//dataSet.push({\n\t//x: xScale(X[i]),\n\t//y: yScale(y[i]),\n\t//});\n\t//}\n\t///* Now need to plot said data */\n\t//svg.selectAll(\"circle\")\n\t//.data(dataSet)\n\t//.enter()\n\t//.append(\"circle\")\n\t//.attr(\"cx\", (d) => d.x)\n\t//.attr(\"cy\", (d) => d.y)\n\t//.attr(\"r\", 2)\n\t//.style(\"fill\", \"#F50257\");\n\t//}\n\trender() {\n\t\treturn <div id=\"nice\"></div>;\n\t}\n}\n\nexport default ScatterPlot;\n","/* \n  Donny Bertucci: @xnought\n  Date Created: 02/15/2021\n  Summary: \n    This file acts as the highest state and act as the controls \n    for the entire application\n*/\nimport React, { Component } from \"react\";\nimport {\n\tTypography,\n\tInput,\n\tBox,\n\tAppBar,\n\tToolbar,\n\tCard,\n\tCardContent,\n\tIconButton,\n\tCardActions,\n\tChip,\n\tTextField,\n\tButton,\n} from \"@material-ui/core\";\nimport { PlusOne, Replay, SlowMotionVideo, Add } from \"@material-ui/icons\";\nimport style from \"./App.css\";\nimport PlayButton from \"./components/PlayButton\";\nimport NN from \"./components/NN\";\nimport ScatterPlot from \"./components/ScatterPlot\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport * as d3 from \"d3\";\nimport { dispose, tidy } from \"@tensorflow/tfjs\";\n\nclass App extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\t/* Treat the app state as the global state */\n\t\tthis.state = {\n\t\t\t/* data: stores the input and lables to the input */\n\t\t\tduringEpoch: false,\n\t\t\tX: null,\n\t\t\ty: null,\n\t\t\tyhat: [],\n\t\t\tbiasData: [],\n\t\t\tweightsData: [],\n\t\t\tdata: {\n\t\t\t\tX: [],\n\t\t\t\ty: [],\n\t\t\t},\n\t\t\t/* Stores the model and model metadata */\n\t\t\tmodel: {\n\t\t\t\tseq: {},\n\t\t\t\tneurons: [],\n\t\t\t\tshape: [1, 6, 6, 1],\n\t\t\t\tloss: null,\n\t\t\t\ty: null,\n\t\t\t\tyhat: [],\n\t\t\t\tdlossdyhat: null,\n\t\t\t\tepoch: 0,\n\t\t\t\tlr: 0.01,\n\t\t\t\tcurve: \"sin\",\n\t\t\t\toptimizer: \"adam\",\n\t\t\t\tscale: 5,\n\t\t\t},\n\t\t\t/* Stores the controls */\n\t\t\tcontrols: {\n\t\t\t\tplaying: false,\n\t\t\t\tspeed: 0,\n\t\t\t},\n\t\t};\n\n\t\t/* Prototype: Functions Binds to \"this\" */\n\t\t/* Main Logic */\n\t\tthis.main = this.main.bind(this);\n\t\tthis.run = this.run.bind(this);\n\t\t/* Neural Network Logic */\n\t\tthis.neuralNetwork = this.neuralNetwork.bind(this);\n\t\t/* Intialization */\n\t\tthis.initDenseNeuron = this.initDenseNeuron.bind(this);\n\t\tthis.initializeModel = this.initializeModel.bind(this);\n\t\tthis.linkModel = this.linkModel.bind(this);\n\t\t/* Epoch calculations */\n\t\tthis.forwardModel = this.forwardModel.bind(this);\n\t\tthis.backwardModel = this.backwardModel.bind(this);\n\t\tthis.updateModel = this.updateModel.bind(this);\n\t\tthis.setInputs = this.setInputs.bind(this);\n\t\t/* Activation Functions */\n\t\t/* Tools for forward */\n\t\t/* Loss Functions */\n\t\t/* Data Generation */\n\t\tthis.generateData = this.generateData.bind(this);\n\t\tthis.genTensorData = this.genTensorData.bind(this);\n\t\tthis.linearData = this.linearData.bind(this);\n\t\t/* Mutators of State */\n\t\tthis.mutate = this.mutate.bind(this);\n\t\tthis.mutateModelNeurons = this.mutateModelNeurons.bind(this);\n\t\tthis.passBack = this.passBack.bind(this);\n\n\t\tthis.mutateAllBackward = this.mutateAllBackward.bind(this);\n\t\tthis.train = this.train.bind(this);\n\t\tthis.printParameters = this.printParameters.bind(this);\n\t\tthis.reset = this.reset.bind(this);\n\t\tthis.asyncPause = this.asyncPause.bind(this);\n\t\tthis.resetParameters = this.resetParameters.bind(this);\n\t\tthis.changeModelLr = this.changeModelLr.bind(this);\n\t\tthis.changeModelOptimizer = this.changeModelOptimizer.bind(this);\n\t}\n\tasync changeModelOptimizer(optimizerChange) {\n\t\tlet model = await this.modelCompile(\n\t\t\toptimizerChange,\n\t\t\tthis.state.model.lr\n\t\t);\n\t\tthis.mutate(\"model\", \"seq\", model);\n\t}\n\n\tchangeModelLr(lrChange) {\n\t\ttf.tidy(() => {\n\t\t\tlet model = this.state.model.seq;\n\t\t\tmodel.optimizer_.learningRate = lrChange;\n\t\t\tthis.mutate(\"model\", \"seq\", model);\n\t\t\treturn undefined;\n\t\t});\n\t}\n\t/* not binded to \"this\" functions */\n\tReLU(number) {\n\t\treturn Math.max(0, number);\n\t}\n\tmseDerivative(yhat, y) {\n\t\treturn 2 * (yhat - y);\n\t}\n\tmseLoss(yhat, y) {\n\t\treturn Math.pow(yhat - y, 2);\n\t}\n\tmult(array1, array2) {\n\t\treturn array1.map((item, i) => {\n\t\t\treturn item * array2[i];\n\t\t});\n\t}\n\tsum(array) {\n\t\treturn array.reduce((a, b) => a + b);\n\t}\n\tgetRandomInt(max) {\n\t\treturn Math.floor(Math.random() * Math.floor(max));\n\t}\n\t/* \n    Name: main\n    Purpose: mutate all the values seen to user by delay of this.state.controls.speed \n    @mutate: this.state.model\n  */\n\tasync main() {\n\t\tconst timer = (ms) => new Promise((res) => setTimeout(res, ms));\n\t\t/* Until broken by user */\n\t\twhile (true) {\n\t\t\t/* Destructure neccesary state */\n\t\t\tconst { controls, model } = this.state;\n\t\t\tconst { playing, speed } = controls;\n\n\t\t\tif (playing === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tawait timer(speed);\n\t\t\t/* this.nerualNetwork(model) */\n\t\t\tawait this.neuralNetwork();\n\t\t\tthis.mutate(\"model\", \"epoch\", model.epoch + 1);\n\t\t}\n\t}\n\n\t/* \n    Name: start\n    Purpose: start the main logic and choose to stop\n    @mutate: this.state.controls.playing\n  */\n\tasync run() {\n\t\tthis.mutate(\"controls\", \"playing\", !this.state.controls.playing);\n\t\tawait this.train(this.state.X, this.state.y);\n\t\t//await this.main();\n\t}\n\n\tasync neuralNetwork() {\n\t\t/* Add the inputs to the first input neuron */\n\t\tawait this.forwardModel(this.getRandomInt(this.state.data.X.length));\n\t\tawait this.backwardModel();\n\t\tawait this.updateModel();\n\t\t// await this.backwardModel(model);\n\t\t// await this.updateModel(model);\n\t}\n\n\t/* \n    Name: initializeModel\n    Purpose: to invoke generation of data and initializing the neural network model\n    @mutate: this.model\n  */\n\tasync initializeModel(shape, start, stop, increment, eqn) {\n\t\t/* Generate Data and set this.state.data*/\n\t\tthis.generateData(start, stop, increment, eqn);\n\t\t// let newsShape = [0, 1, 3, 3, 1];\n\t\t// const numLayers     1  2  3  4 = 4\n\t\tlet newShape = [0, ...shape];\n\t\tconst numLayers = newShape.length;\n\n\t\t/* Define the model */\n\t\t/* [[neuron], [neuron, neuron, neuron],[neuron, neuron, neuron], [neuron]] model: [1,3,3,1] shape */\n\t\tlet model = [];\n\n\t\t/* Add input neuron to the model */\n\t\tfor (let i = 1; i < numLayers; i++) {\n\t\t\t/* Initialize layer */\n\t\t\tlet layer = [];\n\t\t\t/* Get the number of neurons to generate */\n\t\t\tlet numNeurons = newShape[i];\n\t\t\t/* Add neurons to the to the layer */\n\t\t\tfor (let e = 0; e < numNeurons; e++) {\n\t\t\t\t/* Number of inputs from the previous layer to devlay Neuron */\n\t\t\t\tlet neuron = this.initDenseNeuron(newShape[i - 1]);\n\t\t\t\t/* Push to layer */\n\t\t\t\tlayer.push(neuron);\n\t\t\t}\n\t\t\t/* Add to the model */\n\t\t\tmodel.push(layer);\n\t\t}\n\n\t\t/* update the state */\n\t\tthis.mutate(\"model\", \"neurons\", model);\n\t\tthis.mutate(\"model\", \"shape\", shape);\n\t}\n\n\t/* \n    Name: initDenseNeuron\n    @param: numInputs\n    @return: intialized neuron object \n  */\n\tinitDenseNeuron(numInputs) {\n\t\tlet DenseNeuronTemplate = {\n\t\t\tforward: {\n\t\t\t\tinputs: [],\n\t\t\t\tweights: [],\n\t\t\t\tbias: null,\n\t\t\t\tproduct: [],\n\t\t\t\tsum: null,\n\t\t\t\tactivation: null,\n\t\t\t\toutput: null,\n\t\t\t},\n\t\t\tbackward: {\n\t\t\t\tdvalue: null,\n\t\t\t\tdReLU: null,\n\t\t\t\tdBias: null,\n\t\t\t\tdMult: [],\n\t\t\t\tdWeights: [],\n\t\t\t\tdInputs: [],\n\t\t\t\tdNeuron: null,\n\t\t\t},\n\t\t\tlinks: [],\n\t\t};\n\t\tfor (let i = 0; i < numInputs; i++) {\n\t\t\tlet number =\n\t\t\t\t0.1 * (Math.random() < 0.5 ? -Math.random() : Math.random());\n\t\t\t//let number = Math.random();\n\t\t\tDenseNeuronTemplate.forward.weights.push(number);\n\t\t}\n\t\tDenseNeuronTemplate.forward.bias = 0;\n\t\tDenseNeuronTemplate.links = this.linkModel(numInputs);\n\n\t\treturn DenseNeuronTemplate;\n\t}\n\n\tlinkModel(numInputs) {\n\t\treturn this.linearData(0, numInputs - 1, 1);\n\t}\n\n\t/* \n    Name: forwardModel\n    Purpose: one forward pass \n    @mutate: this.model\n  */\n\tasync forwardModel(index) {\n\t\t/* Destructure State */\n\t\tconst { data, model } = this.state;\n\t\tconst { neurons, shape } = model;\n\n\t\t//const index = 1;\n\t\tlet X = [data.X[index]];\n\t\tthis.setInputs(X, 0);\n\t\t/* First perform one forward pass */\n\t\t/* iterate non-input layers */\n\t\tlet io = X;\n\t\tfor (let layer = 1; layer < shape.length; layer++) {\n\t\t\t/* Pass the values from the last neuron */\n\t\t\tthis.setInputs(io, layer);\n\t\t\tio = [];\n\t\t\t/* iterate neuron */\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\tlet { weights, inputs, bias } = neurons[layer][neuron].forward;\n\t\t\t\tlet mult = this.mult(weights, inputs);\n\t\t\t\tlet sum = this.sum(mult) + bias;\n\t\t\t\tif (layer != shape.length - 1) {\n\t\t\t\t\tlet relu = this.ReLU(sum);\n\t\t\t\t}\n\t\t\t\tlet relu = sum;\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"product\",\n\t\t\t\t\tmult,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tthis.mutateModelNeurons(\"forward\", \"sum\", sum, layer, neuron);\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"activation\",\n\t\t\t\t\trelu,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"output\",\n\t\t\t\t\trelu,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tio.push(relu);\n\t\t\t}\n\t\t}\n\t\t/* Calculate loss */\n\t\tconst yhat = this.state.model.neurons[shape.length - 1][0].forward\n\t\t\t.output;\n\t\tlet loss = this.mseLoss(yhat, data.y[index]);\n\t\tthis.mutate(\"model\", \"y\", data.y[index]);\n\t\tthis.mutate(\"model\", \"yhat\", yhat);\n\t\tthis.mutate(\"model\", \"loss\", loss);\n\n\t\t//console.log(`yhat: ${this.state.model.yhat}`);\n\t\t//console.log(`y: ${this.state.data.y[index]}`);\n\t\t//console.log(this.state.model.loss);\n\t}\n\n\t/* \n\t\tName: mutateAllBackward\n\t\t@mutate: this.model.neurons[layer][neuron].backward\n\t*/\n\tmutateAllBackward(\n\t\tdReLU,\n\t\tdBias,\n\t\tdMult,\n\t\tdWeights,\n\t\tdInputs,\n\t\tdNeuron,\n\t\tlayer,\n\t\tneuron\n\t) {\n\t\tthis.mutateModelNeurons(\"backward\", \"dReLU\", dReLU, layer, neuron);\n\t\tthis.mutateModelNeurons(\"backward\", \"dBias\", dBias, layer, neuron);\n\t\tthis.mutateModelNeurons(\"backward\", \"dMult\", dMult, layer, neuron);\n\t\tthis.mutateModelNeurons(\n\t\t\t\"backward\",\n\t\t\t\"dWeights\",\n\t\t\tdWeights,\n\t\t\tlayer,\n\t\t\tneuron\n\t\t);\n\t\tthis.mutateModelNeurons(\"backward\", \"dInputs\", dInputs, layer, neuron);\n\t\tthis.mutateModelNeurons(\"backward\", \"dNeuron\", dNeuron, layer, neuron);\n\t}\n\n\tpassBack(dvalue, currentLayer) {\n\t\tconst { shape } = this.state.model;\n\t\tconst prevLayer = currentLayer - 1;\n\t\tfor (let neuron = 0; neuron < shape[prevLayer]; neuron++) {\n\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\"backward\",\n\t\t\t\t\"dvalue\",\n\t\t\t\tdvalue,\n\t\t\t\tprevLayer,\n\t\t\t\tneuron\n\t\t\t);\n\t\t}\n\t}\n\t/* \n    Name: backwardModel\n    Purpose: compute derivative backwards\n    @mutate: this.model\n  */\n\tasync backwardModel() {\n\t\t/* Destructure the state */\n\t\tconst { model } = this.state;\n\n\t\t/* Destructure model */\n\t\tconst { yhat, y, shape } = model;\n\n\t\tlet outputLayerIndex = shape.length - 1;\n\t\t/* Calculate the loss derivative and pass it to the output neuron */\n\t\tlet dyhat = this.mseDerivative(yhat, y);\n\t\tthis.mutateModelNeurons(\n\t\t\t\"backward\",\n\t\t\t\"dvalue\",\n\t\t\tdyhat,\n\t\t\toutputLayerIndex,\n\t\t\t0\n\t\t);\n\n\t\t/* calculate each layer until we hit the layer before input layer */\n\t\tfor (let layer = outputLayerIndex; layer > 0; layer--) {\n\t\t\tlet dNeurons = [];\n\t\t\tlet dNeuronsSum = 0;\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\t/* Destructure neccesary items from model forward and backward per neuron */\n\t\t\t\tlet { backward, forward } = model.neurons[layer][neuron];\n\t\t\t\tlet { inputs, weights, activation } = forward;\n\t\t\t\tlet { dvalue } = backward;\n\n\t\t\t\tlet dReLU = Math.max(0, activation) * dvalue;\n\t\t\t\tlet dBias = dReLU;\n\t\t\t\tif (layer == outputLayerIndex) {\n\t\t\t\t\tdReLU = dvalue;\n\t\t\t\t}\n\t\t\t\tlet dMult = inputs.map(() => dReLU);\n\t\t\t\tlet dWeights = this.mult(inputs, dMult);\n\t\t\t\tlet dInputs = this.mult(weights, dMult);\n\t\t\t\tlet dNeuron = this.sum(dInputs);\n\n\t\t\t\t/* Add all to the state of the neuron */\n\t\t\t\tthis.mutateAllBackward(\n\t\t\t\t\tdReLU,\n\t\t\t\t\tdBias,\n\t\t\t\t\tdMult,\n\t\t\t\t\tdWeights,\n\t\t\t\t\tdInputs,\n\t\t\t\t\tdNeuron,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\n\t\t\t\t/* Then we want to add dNeuron to an array */\n\t\t\t\tdNeurons.push(dNeuron);\n\t\t\t\t//console.log(`Layer: ${layer}, Neuron: ${neuron}`);\n\t\t\t\t//console.log(backward);\n\t\t\t\t//console.log(forward);\n\t\t\t}\n\t\t\t/* Sum the dNeuron array */\n\t\t\tdNeuronsSum = this.sum(dNeurons);\n\t\t\t/* Pass back the sum to the next layer */\n\t\t\tthis.passBack(dNeuronsSum, layer);\n\t\t}\n\t\t//console.log(this.state.model.neurons);\n\n\t\t/* Given current layer I want to pass back to previous layer */\n\t\t//this.passBack(dvalue, layer);\n\t\t//console.log(neurons[layer - 1]);\n\n\t\t///* Start at last layer */\n\t\t//for(let layer = shape.length - 1; layer >= 0; layer-- )\n\t\t//{\n\t\t//let dNeuronArray = [];\n\t\t//let dvalueSumLayer = 0;\n\t\t///* Itererate through each neuron per layer */\n\t\t//for(let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t///* Destructure Neuron */\n\t\t//let { activation, weights, inputs } = neurons[layer][neuron].forward;\n\t\t//let inputLength = inputs.length;\n\n\t\t//}\n\t\t//}\n\n\t\t///* Destructure Neuron */\n\t\t//let { activation, weights, inputs } = neurons[layer][neuron].forward;\n\t\t//let inputLength = inputs.length;\n\n\t\t//let lastNeuron = neurons[layer][neuron];\n\t\t///* Calculate the loss derivative */\n\t\t//let dyhat = this.mseDerivative(yhat, y);\n\n\t\t///* Sum the values needed to pass back */\n\t\t//let dNeuronArray = [];\n\t\t//let dvalueNextLayer = 0;\n\n\t\t///* Pass the value back*/\n\t\t//let dvalue = dyhat;\n\t\t//let dReLU = Math.max(0, activation) * dvalue;\n\t\t//let dBias = dReLU;\n\t\t//let dMult = inputs.map(() => dReLU);\n\t\t//let dWeights = this.mult(inputs, dMult);\n\t\t//let dInputs = this.mult(weights, dMult);\n\t\t//let dNeuron = this.sum(dInputs);\n\t\t///* Add dNeuron to the layers output */\n\t\t//dNeuronArray.push(dNeuron);\n\n\t\t///* At the end of first loop of layer iteration */\n\t\t//dvalueNextLayer = this.sum(dNeuronArray);\n\n\t\t//console.log(lastNeuron);\n\t\t///* Pass the derivative input back */\n\t\t//this.mutateAllBackward(\n\t\t//dvalue,\n\t\t//dReLU,\n\t\t//dBias,\n\t\t//dMult,\n\t\t//dWeights,\n\t\t//dInputs,\n\t\t//dNeuron,\n\t\t//layer,\n\t\t//neuron\n\t\t//);\n\t\t/* Update all of the parameters */\n\t\t//console.log(`dinput: ${dvalue}`);\n\t\t//console.log(`Activation: ${activation}`);\n\t\t//console.log(`dReLU: ${dReLU}`);\n\t\t//console.log(`DBias: ${dBias}`);\n\t\t//console.log(`DMult: [${dMult.toString()}]`);\n\t\t//console.log(`Dweights: [${dWeights.toString()}]`);\n\t\t//console.log(`Dinputs: [${dInputs.toString()}]`);\n\t\t//this.mutateModelNeurons(\n\t\t//\"backward\",\n\t\t//\"dprevNeurondLoss\",\n\t\t//dlossdyhat,\n\t\t//shape.length - 1,\n\t\t//0\n\t\t//);\n\n\t\t/* Pass back to neurons based on linkage */\n\t\t/* We want to now pass it back to the last neuron */\n\n\t\t/* Compute Derivative of loss */\n\t\t/* Iterate backwards of neurons */\n\t\t/* Compute derivative of a neuron */\n\t\t/* print the derivatives */\n\t}\n\n\tgradientDescent(lr, param, dparam) {\n\t\treturn param - lr * dparam;\n\t}\n\t/* \n    Name: updateModel\n    Purpose: to perform gradient descent and update the weights\n    @mutate: this.model\n  */\n\tasync updateModel() {\n\t\t/* Destructuring the state */\n\t\tconst { model } = this.state;\n\n\t\tconst { shape, lr, neurons } = model;\n\t\t/* Use the derivatives to perform gradient descent */\n\t\t/* Iterate through each and subtract weights by itself times the derivative of weights or biases */\n\t\tfor (let layer = 1; layer < shape.length; layer++) {\n\t\t\tfor (let neuron = 0; neuron < shape[layer]; neuron++) {\n\t\t\t\tlet { weights, bias } = neurons[layer][neuron].forward;\n\t\t\t\tlet { dWeights, dBias } = neurons[layer][neuron].backward;\n\t\t\t\t//*  */console.log(`Layer ${layer}, Neuron: ${neuron}`);\n\t\t\t\t/* Update weights */\n\t\t\t\tlet updatedWeights = [];\n\t\t\t\tfor (let weight = 0; weight < shape[layer - 1]; weight++) {\n\t\t\t\t\tupdatedWeights.push(\n\t\t\t\t\t\tthis.gradientDescent(\n\t\t\t\t\t\t\tlr,\n\t\t\t\t\t\t\tweights[weight],\n\t\t\t\t\t\t\tdWeights[weight]\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t/* Update bias */\n\t\t\t\tlet updatedBias = this.gradientDescent(lr, bias, dBias);\n\n\t\t\t\t/* Update the model weights and biases */\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"weights\",\n\t\t\t\t\tupdatedWeights,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\t\"forward\",\n\t\t\t\t\t\"bias\",\n\t\t\t\t\tupdatedBias,\n\t\t\t\t\tlayer,\n\t\t\t\t\tneuron\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t/* We want to start from the beginning and subt */\n\t}\n\t/* \n    Name: setInputs\n    @param: inputs\n    @param: currentLayer\n    @mutate: this.state.model.neurons[currentLayer]\n  */\n\tsetInputs(inputs, currentLayer) {\n\t\t/* Destructure the neurons */\n\t\tconst { neurons } = this.state.model;\n\t\t/* Iterate through each neuron and set its inputs */\n\t\tfor (let i = 0; i < neurons[currentLayer].length; i++) {\n\t\t\tthis.mutateModelNeurons(\n\t\t\t\t\"forward\",\n\t\t\t\t\"inputs\",\n\t\t\t\tinputs,\n\t\t\t\tcurrentLayer,\n\t\t\t\ti\n\t\t\t);\n\t\t}\n\t}\n\n\t/* \n    Name: generateData\n    @param: start\n    @param: end\n    @param increment\n    @param: equation (a function the user passes in)\n    @mutate: this.data\n  */\n\tgenerateData(start, stop, increment, equation) {\n\t\tif (typeof equation === \"function\" && equation(start) !== undefined) {\n\t\t\t/* Create the X input data */\n\t\t\tconst X = this.linearData(start, stop, increment);\n\t\t\t/* Create the labels to the input data */\n\t\t\tconst y = X.map((input) => {\n\t\t\t\treturn equation(input).toFixed(3);\n\t\t\t});\n\t\t\t/* Set State */\n\t\t\tthis.mutate(\"data\", \"X\", X);\n\t\t\tthis.mutate(\"data\", \"y\", y);\n\t\t} else {\n\t\t\tconsole.error(\n\t\t\t\t\"Enter a valid equation: must be function with input parameter that returns a number\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/* \n    Name: linearData\n    @param: start\n    @param: end\n    @param increment\n    @return: output array\n  */\n\tlinearData(start, end, increment) {\n\t\tlet output = [];\n\t\tfor (let i = start; i <= end; i += increment) {\n\t\t\toutput.push(i);\n\t\t}\n\t\treturn output;\n\t}\n\n\t/* \n    Name: mutate\n    @param key: corresponds to this.state.key\n    @param subkey: corresponds to this.state.key.subkey\n    @param value\n    @mutate: this.state.key.subkey with value\n  */\n\tmutate(key, subkey, value) {\n\t\t/* copy of the state */\n\t\ttf.tidy(() => {\n\t\t\tlet state = { ...this.state };\n\t\t\t/* If this.state.key.subkey exists */\n\t\t\tif (key in state && subkey in state[key]) {\n\t\t\t\t/* Mutate the state */\n\t\t\t\tstate[key][subkey] = value;\n\t\t\t\tthis.setState({ state });\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Could not be found in state\");\n\t\t\t}\n\t\t\treturn undefined;\n\t\t});\n\t}\n\n\t/* \n    Name: mutateModelNeurons\n    @param key: corresponds to this.state.key\n    @param subkey: corresponds to this.state.key.subkey\n    @param value\n    @param layer\n    @param neuron\n    @mutate: this.state.key.subkey with value\n  */\n\tmutateModelNeurons(key, subkey, value, layer, neuron) {\n\t\t/* copy of the state */\n\t\tlet neurons = { ...this.state.model.neurons };\n\t\t/* If this.state.key.subkey exists */\n\t\tif (neurons[layer][neuron][key][subkey] !== undefined) {\n\t\t\t/* Mutate the state */\n\t\t\tneurons[layer][neuron][key][subkey] = value;\n\t\t\tthis.setState({\n\t\t\t\t...this.state,\n\t\t\t\tmodel: { ...this.state.model, neurons: neurons },\n\t\t\t});\n\t\t} else {\n\t\t\tconsole.error(\"Could not be found in state\");\n\t\t}\n\t}\n\tpredicitons() {\n\t\tconst { data } = this.state;\n\t\tfor (let i = 0; i < data.X.length; i++) {\n\t\t\tthis.forwardModel();\n\t\t}\n\t}\n\n\ttensorToArray(tensor) {\n\t\treturn Array.from(tensor.dataSync());\n\t}\n\n\tasync addModel(model) {\n\t\treturn tf.tidy(() => {\n\t\t\tlet shape = this.state.model.shape;\n\t\t\tmodel.add(\n\t\t\t\ttf.layers.dense({\n\t\t\t\t\tinputShape: [1],\n\t\t\t\t\tunits: shape[1],\n\t\t\t\t\tactivation: \"relu\",\n\t\t\t\t\tuseBias: true,\n\t\t\t\t})\n\t\t\t);\n\t\t\tfor (let layer = 2; layer < shape.length - 1; layer++) {\n\t\t\t\tmodel.add(\n\t\t\t\t\ttf.layers.dense({\n\t\t\t\t\t\tunits: shape[layer],\n\t\t\t\t\t\tactivation: \"relu\",\n\t\t\t\t\t\tuseBias: true,\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t\tmodel.add(\n\t\t\t\ttf.layers.dense({\n\t\t\t\t\tunits: 1,\n\t\t\t\t\tactivation: \"linear\",\n\t\t\t\t\tuseBias: true,\n\t\t\t\t})\n\t\t\t);\n\n\t\t\treturn model;\n\t\t});\n\t}\n\tasync modelCompile(optimizer, lr) {\n\t\tlet model = tf.sequential();\n\t\tawait this.addModel(model);\n\t\tmodel.compile({\n\t\t\toptimizer: optimizer(lr),\n\t\t\tloss: \"meanSquaredError\",\n\t\t});\n\t\treturn model;\n\t}\n\tasync train(X, y) {\n\t\tlet { model } = this.state.model.seq;\n\t\t//await model.fit(X, y, { epochs: 1000 });\n\t\t//model.predict(X);\n\t\t//console.log(yArr);\n\t\t//console.log(XArr);\n\t\tconst timer = (ms) => new Promise((res) => setTimeout(res, ms));\n\t\t/* Until broken by user */\n\t\tlet play = this.state.controls.playing;\n\t\twhile (play !== false) {\n\t\t\t/* Destructure neccesary state */\n\t\t\tconst { playing, speed } = this.state.controls;\n\t\t\tconst { epoch } = this.state.model;\n\t\t\tplay = playing;\n\t\t\tthis.setState({ duringEpoch: true });\n\t\t\tthis.mutate(\"model\", \"epoch\", epoch + 1);\n\t\t\tconst h = await model.fit(X, y, {\n\t\t\t\tepochs: 1,\n\t\t\t});\n\t\t\tawait this.printParameters(model);\n\t\t\tlet yhat = model.predict(X);\n\t\t\tthis.mutate(\"model\", \"loss\", h.history.loss[0]);\n\t\t\tthis.mutate(\"model\", \"yhat\", this.tensorToArray(yhat));\n\t\t\tthis.setState({ duringEpoch: false });\n\t\t\tawait timer(speed);\n\t\t\t/* this.nerualNetwork(model) */\n\t\t}\n\t}\n\tasync genTensorData(eqn, scaled) {\n\t\tawait tf.ready();\n\t\tlet XTensor = tf.linspace(\n\t\t\t-this.state.model.scale,\n\t\t\tthis.state.model.scale,\n\t\t\t60\n\t\t);\n\t\tlet yTensor;\n\t\tyTensor = tf.mul(eqn(XTensor), scaled);\n\t\tlet yhatTensor = tf.zerosLike(XTensor);\n\t\tlet X = this.tensorToArray(XTensor);\n\t\tlet y = this.tensorToArray(yTensor);\n\t\tlet yhat = this.tensorToArray(yhatTensor);\n\n\t\tthis.setState({\n\t\t\t...this.state,\n\t\t\tX: XTensor,\n\t\t\ty: yTensor,\n\t\t\tdata: { X, y },\n\t\t\tmodel: { ...this.state.model, yhat },\n\t\t});\n\t}\n\tasync printParameters(model) {\n\t\tlet weightSet = [];\n\t\tlet biasSet = [];\n\t\tfor (let i = 0; i < model.getWeights().length; i++) {\n\t\t\t(i % 2 == 0 ? weightSet : biasSet).push(\n\t\t\t\tArray.from(model.getWeights()[i].dataSync())\n\t\t\t);\n\t\t}\n\t\t//console.log(model.layers[2].getWeights()[1].dataSync());\n\t\tthis.setState({\n\t\t\t...this.state,\n\t\t\tbiasData: biasSet,\n\t\t\tweightsData: weightSet,\n\t\t});\n\t\t//for (let layer = 1; layer < model.layers.length; layer++) {\n\t\t//console.log(`Layer: ${layer} `);\n\t\t//model.layers[layer].getWeights()[0].print();\n\n\t\t//model.layers[layer].getWeights()[1].print();\n\t\t//}\n\t}\n\tasync asyncPause() {\n\t\tthis.mutate(\"controls\", \"playing\", false);\n\t}\n\tasync resetParameters(scale) {\n\t\tlet eqn;\n\t\tlet optimizer;\n\t\tif (this.state.model.curve === \"sin\") {\n\t\t\teqn = tf.sin;\n\t\t} else if (this.state.model.curve === \"tanh\") {\n\t\t\teqn = tf.tanh;\n\t\t} else if (this.state.model.curve === \"cos\") {\n\t\t\teqn = tf.cos;\n\t\t}\n\t\tif (this.state.model.optimizer == \"adam\") {\n\t\t\toptimizer = tf.train.adam;\n\t\t} else if (this.state.model.optimizer == \"sgd\") {\n\t\t\toptimizer = tf.train.sgd;\n\t\t}\n\t\tawait this.genTensorData(eqn, scale);\n\t\tlet model = await this.modelCompile(optimizer, this.state.model.lr);\n\t\tawait this.printParameters(model);\n\t\tthis.setState({\n\t\t\t...this.state,\n\t\t\tmodel: { ...this.state.model, seq: model, epoch: 0, loss: null },\n\t\t});\n\t}\n\n\tasync reset(scale) {\n\t\tthis.asyncPause();\n\t\tthis.resetParameters(scale);\n\t\t//;this.mutate(\"model\", \"seq\", model);\n\t\t//;this.setState({ yhat: [] });\n\t\t//;this.mutate(\"model\", \"epoch\", 0);\n\t}\n\tasync componentDidMount() {\n\t\t/* First lets choose the data */\n\n\t\ttf.tidy(() => {\n\t\t\tthis.genTensorData(tf.sin, this.state.model.scale);\n\t\t\treturn undefined;\n\t\t});\n\t\tlet model = await this.modelCompile(tf.train.adam, this.state.model.lr);\n\t\ttf.tidy(() => {\n\t\t\tthis.mutate(\"model\", \"seq\", model);\n\t\t\tthis.printParameters(model);\n\t\t});\n\t\t//model.optimizer_ = tf.train.sgd(0.1);\n\t\t//model.optimizer_.learningRate = 0.001;\n\n\t\t//const paths = d3\n\t\t//.select(\"#app\")\n\t\t//.select(\"#nn\")\n\t\t//.selectAll(\"path\")\n\t\t//.attr(\"class\", \"edge\");\n\t\t//epochs: 10,\n\t\t//});\n\t\t//console.log(this.tensorToArray(model.predict(X)));\n\t\t//function lin(x) {\n\t\t//return x;\n\t\t//}\n\t\t//await this.initializeModel([1, 2, 2, 1], 0, 3.14, 1.57, Math.sin);\n\t\t//console.log(this.state.model.neurons);\n\t\t//await this.forwardModel();\n\t\t////console.log(\"Foward Pass\");\n\t\t////console.log(this.state.model.neurons);\n\t\t////console.log(\"Backward Pass and Update\");\n\t\t//await this.backwardModel();\n\t\t//await this.updateModel();\n\t\t//console.log(this.state.model.neurons);\n\t\t//await this.forwardModel();\n\t\t//console.log(\"Foward Pass\");\n\t\t//console.log(this.state.model.neurons);\n\t\t//console.log(\"Backward Pass and Update\");\n\t\t//await this.backwardModel();\n\t\t//await this.updateModel();\n\t\t//console.log(this.state.model.neurons);\n\t}\n\tcomponentDidUpdate() {\n\t\t//console.table(tf.memory());\n\t}\n\tshouldComponentUpdate() {\n\t\tif (this.state.duringEpoch) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\trender() {\n\t\t/* Destructure State*/\n\t\tconst { model, controls } = this.state;\n\n\t\t/* Destructuring model */\n\t\tconst { epoch, loss, shape } = model;\n\n\t\tlet newShape = [...shape];\n\t\tnewShape.splice(0, 1);\n\t\tnewShape.splice(newShape.length - 1, 1);\n\t\t//console.log(newShape);\n\t\tconst lrs = [0.001, 0.01, 0.1, 0.3, (1.0).toFixed(1)];\n\t\tconst optimizers = [\"adam\", \"sgd\"];\n\t\tconst dataSets = [\n\t\t\t{ label: \"sin\", eqn: tf.sin, scale: 5 },\n\t\t\t{ label: \"cos\", eqn: tf.cos, scale: 5 },\n\t\t\t{ label: \"tanh\", eqn: tf.tanh, scale: 5 },\n\t\t];\n\n\t\t/* Destructuring of model */\n\n\t\t/* Destructure render */\n\t\tconst PlayButtonClick = (\n\t\t\t// eslint-disable-next-line\n\t\t\t<a\n\t\t\t\tonClick={async () => {\n\t\t\t\t\tawait this.run();\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<PlayButton playing={controls.playing} />\n\t\t\t</a>\n\t\t);\n\n\t\treturn (\n\t\t\t<div id=\"app\">\n\t\t\t\t<AppBar\n\t\t\t\t\tposition=\"static\"\n\t\t\t\t\tstyle={{ background: \"#f50257\", color: \"white\" }}\n\t\t\t\t>\n\t\t\t\t\t<Toolbar>\n\t\t\t\t\t\t<Typography variant=\"h6\">\n\t\t\t\t\t\t\tBackpropagation Visualizer\n\t\t\t\t\t\t</Typography>\n\t\t\t\t\t</Toolbar>\n\t\t\t\t</AppBar>\n\n\t\t\t\t<Box display=\"flex\" justifyContent=\"center\" marginTop={10}>\n\t\t\t\t\t<Box width={400}>\n\t\t\t\t\t\t<Card variant=\"outlined\">\n\t\t\t\t\t\t\t<CardContent>\n\t\t\t\t\t\t\t\t<Typography\n\t\t\t\t\t\t\t\t\tvariant=\"caption\"\n\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\tcolor: \"rgb(245, 2, 87, 0.5)\",\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tControl Center\n\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t<Typography variant=\"h4\">\n\t\t\t\t\t\t\t\t\tEpochs: {epoch}\n\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t<Typography variant=\"h6\">\n\t\t\t\t\t\t\t\t\tloss: {loss == null ? \"\" : loss.toFixed(6)}\n\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t<IconButton\n\t\t\t\t\t\t\t\t\t\tdisabled={this.state.controls.playing}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tthis.reset(model.scale);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Replay />\n\t\t\t\t\t\t\t\t\t</IconButton>\n\t\t\t\t\t\t\t\t\t{PlayButtonClick}\n\t\t\t\t\t\t\t\t\t<IconButton\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tcolor:\n\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.speed == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"grey\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"#FFC006\",\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\"controls\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"speed\",\n\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.speed == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t? 100\n\t\t\t\t\t\t\t\t\t\t\t\t\t: 0\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<SlowMotionVideo />\n\t\t\t\t\t\t\t\t\t</IconButton>\n\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t</CardContent>\n\t\t\t\t\t\t</Card>\n\n\t\t\t\t\t\t<Box marginTop={5}>\n\t\t\t\t\t\t\t<Card variant=\"outlined\">\n\t\t\t\t\t\t\t\t<CardContent>\n\t\t\t\t\t\t\t\t\t<Typography\n\t\t\t\t\t\t\t\t\t\tvariant=\"caption\"\n\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\tcolor: \"rgb(245, 2, 87, 0.5)\",\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\tModel Initialization\n\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Typography variant=\"caption\">\n\t\t\t\t\t\t\t\t\t\t\tOptimizer\n\t\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t\t{optimizers.map((optimizer, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\tdisabled={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.playing\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\t\t\t\tlabel={optimizer}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.optimizer == optimizer\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"default\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"optimizer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toptimizer\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.changeModelOptimizer(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toptimizer == \"sgd\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? tf.train.sgd\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: tf.train.adam\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(model.scale);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Typography variant=\"caption\">\n\t\t\t\t\t\t\t\t\t\t\tLearning Rate\n\t\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t\t{lrs.map((num, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\t\t\t\tlabel={`${num}`}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.model.lr ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${num}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"default\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"lr\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnum\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.changeModelLr(num);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Typography variant=\"caption\">\n\t\t\t\t\t\t\t\t\t\t\tData Set\n\t\t\t\t\t\t\t\t\t\t</Typography>\n\t\t\t\t\t\t\t\t\t\t{dataSets.map((item, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\tdisabled={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.controls.playing\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\t\t\t\t\t\t\tlabel={item.label}\n\t\t\t\t\t\t\t\t\t\t\t\tcolor={\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.state.model.curve ==\n\t\t\t\t\t\t\t\t\t\t\t\t\titem.label\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"default\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(model.scale);\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"curve\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titem.label\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.genTensorData(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titem.eqn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titem.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t</CardContent>\n\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t</Box>\n\t\t\t\t\t</Box>\n\t\t\t\t\t<Box marginLeft={10}>\n\t\t\t\t\t\t<NN\n\t\t\t\t\t\t\tweights={this.state.weightsData}\n\t\t\t\t\t\t\tbiases={this.state.biasData}\n\t\t\t\t\t\t\tshape={this.state.model.shape}\n\t\t\t\t\t\t\tplaying={this.state.controls.playing}\n\t\t\t\t\t\t\tslowed={this.state.controls.speed != 0}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Card variant=\"outlined\" style={{ minWidth: 875 }}>\n\t\t\t\t\t\t\t\t<Box justifyContent=\"start\" display=\"flex\">\n\t\t\t\t\t\t\t\t\t<CardActions>\n\t\t\t\t\t\t\t\t\t\t<Box marginRight={11.5}>\n\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape = model.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (!(shape.length > 4)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.length - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.push(2);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.push(1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"path\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rect\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\tAdd Layer\n\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t{newShape.map((num, i) => (\n\t\t\t\t\t\t\t\t\t\t\t<Box marginRight={17}>\n\t\t\t\t\t\t\t\t\t\t\t\t<Box marginBottom={1}>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel={\"–\"}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet e = i + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? shape[e]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: shape[e] -\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t!shape[e] == 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"path\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rect\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t\t\t<Box>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Chip\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabel={\"+\"}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet e = i + 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape[e] >= 8\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? shape[e]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: shape[e] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (shape[i] <= 8) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"path\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#app\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"#nn\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"svg\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rect\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t></Chip>\n\t\t\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t\t))}\n\n\t\t\t\t\t\t\t\t\t\t<Box>\n\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttf.tidy(() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet shape = model.shape;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (shape.length > 2) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.length - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.length - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape.push(1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"path\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\td3.select(\"#app\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"#nn\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.select(\"svg\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.selectAll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"rect\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.remove();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.mutate(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"model\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"shape\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshape\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.reset(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.scale\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\tRemove Layer\n\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t\t\t</CardActions>\n\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t</NN>\n\t\t\t\t\t</Box>\n\t\t\t\t\t<Box marginLeft={10}>\n\t\t\t\t\t\t<ScatterPlot\n\t\t\t\t\t\t\twidth={300}\n\t\t\t\t\t\t\theight={300}\n\t\t\t\t\t\t\tpadding={0}\n\t\t\t\t\t\t\tstart={-this.state.model.scale}\n\t\t\t\t\t\t\tstop={this.state.model.scale}\n\t\t\t\t\t\t\tX={this.state.data.X}\n\t\t\t\t\t\t\ty={this.state.data.y}\n\t\t\t\t\t\t\tyhat={this.state.model.yhat}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</Box>\n\t\t\t\t</Box>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}